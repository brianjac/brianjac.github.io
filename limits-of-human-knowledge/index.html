<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head>   <title>On the Limits of Human Knowledge</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="limits-of-human-knowledge.tex"> 
<meta name="date" content="2017-10-08 15:54:00"> 
<link rel="stylesheet" type="text/css" href="limits-of-human-knowledge.css"> 
 <!-- Global Site Tag (gtag.js) - Google Analytics --> 
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107695556-1"></script> 
<script> 
window.dataLayer = window.dataLayer || []; 
function gtag(){dataLayer.push(arguments);} 
gtag('js', new Date()); 
gtag('config', 'UA-107695556-1'); 
</script> 
</head><body 
>
   <div class="maketitle">
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class="titleHead">On the Limits of Human Knowledge</h2>
<div class="author" ></div><br />
<div class="date" ><span 
class="cmr-12">October 8th, 2017</span></div>
   </div>
<div class="center" 
>
<!--l. 14--><p class="noindent" >
<!--l. 15--><p class="noindent" ><a 
href="../index.html" >All Articles</a></div>
<!--l. 17--><p class="noindent" >A few weeks ago one of the people that I follow on Twitter asked a question about the
possible extent of human knowledge. I wrote a response, which I shared in a private
forum. In order to make the response more publically available, I&#8217;ve decided to post
it here, with some minor updates.<br 
class="newline" />
   <div class="fbox">&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;                       <div class="minipage">Will humanity ever be able to know absolutely everything that is to be known? Or is
there infinite knowledge waiting to be obtained?<br 
class="newline" />
                                                                                                       <div class="flushright" 
>
<!--l. 27--><p class="noindent" >
                                                                                  &#8212; <a 
href="https://twitter.com/ShmootzRL/status/909986948680384512" >@ShmootzRL</a></div></div> </div>
<!--l. 29--><p class="indent" >   The question presents two choices: either knowledge is finite, and we will
eventually have obtained all of it, or knowledge is infinite, and therefore there will
always be something else for us to learn. I don&#8217;t believe that the first choice is
possible even if there is finite knowledge, and so that is what we will focus on today.
Perhaps at a future date we will tackle the question of infinite knowledge
separately.<br 
class="newline" />
<!--l. 31--><p class="indent" >   We can see that it is not possible for humanity to know everything there is to
know because we can construct information which we can prove exists, but which we
cannot construct directly. One example of such information is something called
Chaitan&#8217;s Constant. Chaitan&#8217;s Constant (as specified later) is a rational number. It is
a specific rational number. It is a rational number which you could write down
on a sufficiently large piece of paper. Nevertheless, its specific value is not
                                                                  

                                                                  
just unknown to humanity, but is fundamentally unknowable based on our
understanding of mathematics. This means that humanity can never know
&#8220;everything,&#8221; because there will always exist knowledge which is out of our
reach.<br 
class="newline" />
<!--l. 33--><p class="indent" >   There are some conditions which are worth noting under which this argument
falls apart. If we somehow develop a method for performing infinite computation in
finite time, then the problem gets murkier. With the ability to do infinite
computation in finite time, you can compute Chaitan&#8217;s Constant directly. You can
also do things like list out every consequence of every axiomatic system you can think
of, and indeed list out every possible axiomatic system while you&#8217;re at it. Does it
count to know everything if you could never think each unique thought in sequence,
even if you lived a thousand lifetimes? Even if every person is collaboratively
thinking every thought in sequence for the lifetime of the universe? Since our
understanding of the universe does not give us any hint that operating with such
infinite computations is possible, and because it somewhat exceeds the scope of what
I really want to talk about (uncomputable numbers), we will disregard the
possibility.
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Theorem: Chaitin&#8217;s Constant is Unknowable</h3>
<!--l. 36--><p class="noindent" >For some program encoding (like C, Perl, Lambda Calculus, Turing Machines, etc.),
and for every <span 
class="cmmi-10">n</span>, there exists a value &Omega;<sub><span 
class="cmmi-7">n</span></sub> which corresponds to the proportion of
programs of length <span 
class="cmmi-10">n </span>which terminate. This value is Chaitin&#8217;s Constant for that
program encoding and that length. I will shorthand that phrase as Chaitin&#8217;s
Constant or &Omega;<sub><span 
class="cmmi-7">n</span></sub> for simplicity. We will leave the particular program encoding
unspecified. We can, in general, neither compute nor prove the value of any of
Chaitin&#8217;s Constants, with exceptions for degenerate cases like programs of length
zero, or programs which are too short to have loops represented in our chosen
encoding.<br 
class="newline" />
<!--l. 38--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-20001.1"></a>Lemma: The Undecidability of the Halting Problem</h4>
<!--l. 39--><p class="noindent" >It is not possible to write a program in a Turing Complete language which
determines whether another arbitrary program written in a Turing Complete
language eventually halts.<br 
class="newline" />
<!--l. 41--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-30001.2"></a>Proof of Lemma</h4>
                                                                  

                                                                  
<!--l. 42--><p class="noindent" >Let <span 
class="cmtt-10">snooper(p,i) </span>be a function which returns true if its input program <span 
class="cmtt-10">p</span>
halts on input <span 
class="cmtt-10">i</span>, and false if <span 
class="cmtt-10">p </span>runs forever on input <span 
class="cmtt-10">i</span>. We can then write a
program <span 
class="cmtt-10">halter() </span>which takes as input a program <span 
class="cmtt-10">p</span>, calls <span 
class="cmtt-10">snooper(p,p)</span>,
and enters an infinite loop if <span 
class="cmtt-10">snooper(p,p) </span>returns true. If <span 
class="cmtt-10">snooper(p,p)</span>
returns false, <span 
class="cmtt-10">halter(p) </span>returns true. Now there are two options: either
<span 
class="cmtt-10">halter(halter) </span>returns true, or <span 
class="cmtt-10">halter(halter) </span>does not terminate. If
<span 
class="cmtt-10">halter(halter) </span>terminates, returning true, then <span 
class="cmtt-10">snooper(halter,halter)</span>
must return false, implying that <span 
class="cmtt-10">halter(halter) </span>does not terminate. If
<span 
class="cmtt-10">halter(halter) </span>does not terminate, then <span 
class="cmtt-10">snooper(halter,halter) </span>must
return true, implying <span 
class="cmtt-10">halter(halter) </span>does terminate. Either way, we have
a contradiction that arises from the existence of the <span 
class="cmtt-10">snooper program.</span>
Therefore we cannot write this <span 
class="cmtt-10">snooper </span>program; its existence leads to a
contradiction.<br 
class="newline" />
<!--l. 44--><p class="indent" >   <span 
class="cmti-10">Brief addendum: This proof is a bear to get right, and I&#8217;ve gotten minor details</span>
<span 
class="cmti-10">wrong every time I&#8217;ve presented it. Let me know if you spot an error.</span><br 
class="newline" />
<!--l. 46--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">1.3   </span> <a 
 id="x1-40001.3"></a>Proof of our Theorem:</h4>
<!--l. 47--><p class="noindent" >By Lemma 0, we cannot write a program which determines whether or not an input
program halts without violating the rule that snooper-like programs cannot exist. If
we know Chaitin&#8217;s constant &Omega;<sub><span 
class="cmmi-7">n</span></sub><span 
class="cmmi-10">, </span>then we can write such a program in the following
way, assuming we are attempting to determine the halting of a program of length
<span 
class="cmmi-10">n </span>:<br 
class="newline" />
<!--l. 49--><p class="indent" >
  <dl class="enumerate"><dt class="enumerate">
1. </dt><dd 
class="enumerate">Enumerate all possible programs of length <span 
class="cmmi-10">n.</span>
  </dd><dt class="enumerate">
2. </dt><dd 
class="enumerate">Execute one instruction from each program in sequence.
  </dd><dt class="enumerate">
3. </dt><dd 
class="enumerate">Check your ratio of programs which have terminated over all programs.
  </dd><dt class="enumerate">
4. </dt><dd 
class="enumerate">If that ratio matches &Omega;<sub><span 
class="cmmi-7">n</span></sub> to enough decimal places that adding a single newly
  terminating program to the ratio would cause it to go over &Omega;<sub><span 
class="cmmi-7">n</span></sub><span 
class="cmmi-10">, </span>then the
  program we are interested in must not terminate and we can return that it
  does not halt. Alternately, if the program has halted, we can return that it
  halts.
  </dd><dt class="enumerate">
5. </dt><dd 
class="enumerate">If neither of the above cases hold, then we go back to 2.</dd></dl>
                                                                  

                                                                  
<!--l. 57--><p class="indent" >   Essentially, what&#8217;s happening here is we are conducting a parallel search for all
terminating programs, where we know we are done when we have reached Chaitin&#8217;s
Constant. Since this is a snooper-like program (even though it would run in a truly
horrendous amount of real-world computation time, even if you have a <span 
class="cmti-10">really </span>fast
computer) it cannot exist. Since its existence is predicated on our knowledge of
Chaitin&#8217;s constant, we cannot mathematically prove the value of Chatin&#8217;s constant. If
we can&#8217;t prove a value correct in any way, we cannot say it is correct, and therefore
we cannot know it.  
</body></html> 

                                                                  


